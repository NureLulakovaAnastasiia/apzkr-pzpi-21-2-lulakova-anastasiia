Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА

з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для управління притулком для тварин

 
Студентка гр. ПЗПІ-21-2

Керівник роботи




Комісія:





_______________ Лулакова А.В.
(підпис)
____________ доц. Лещинський В.О.
(підпис)
Роботу захищено «__»червня 2024 р.
  з оцінкою ______________________

_____________ доц. Лещинський В.О.
(підпис)
_____________ доц. Лещинська І.О.
(підпис)
_____________ ст.викл. Сокорчук І.П.
(підпис) 

Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук                Кафедра програмної інженерії                    
Спеціальність 121 – Інженерія програмного забезпечення                                               
Курс                         3                        Семестр                             6                                        
Навчальна дисципліна Архітектура програмного забезпечення                                  
ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ  
                                   Лулаковій Анастасії Вячеславівні                                                     
1. Тема роботи: «Програмна система для управління притулком для домашніх        тварин»                                                                                                                                     
2. Термін узгодження завдання з курсової роботи « 19 »лютого 2024 р.
3. Термін здачі студентом закінченої роботи « 30 »  червня  2024 р.
4. Вихідні дані до проекту: В програмній системі передбачити: управління персоналом, надання завдань, догляд за тваринами, управління сховищем. Використовувати ОС Windows 10, СКБД Microsoft SQL Server 2019, середовище розробки Microsoft Visual Studio 2022                                                                                   
5. Зміст пояснювальної записки (перелік питань, що належить розробити): вступ,        аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки                                                                   
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень): схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки                                                                                                                             
 
КАЛЕНДАРНИЙ ПЛАН 


№	Назва етапів курсової роботи	Термін виконання етапів роботи	Примітка
1	Функціональна специфікація програмного проекту	14.04.2024	виконано
2	Проектування програмного проекту	26.04.2024	виконано
3	Кодування програмного проекту	06.06.2024	виконано
4	Оформлення пояснювальної записки	15.06.2024	виконано
5	Захист курсової роботи	30.06.2024	виконано

Дата видачі завдання « 19 »лютого 2024 р.
Керівник                                                                              доц. Лещинський В. О.
 		(підпис)

Завдання прийняла до виконання
ст. гр. ПЗПІ-21-2                                                                 Лулакова А. В.
         (підпис)




 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 81 с., 27 рис., 2 табл., 3 додатки, 3 джерела.
ПРИТУЛКИ, УПРАВЛІННЯ, ВОЛЬЄР, ТВАРИНА, ПЕРСОНАЛ, СКЛАД, ХАРЧУВАННЯ.
Об’єктом дослідження є сфера піклування про безхатніх тварин, а саме притулків та актуальне на сьогоднішній день питання щодо оптимізації управління притулками для тварин через автоматизацію рутинних завдань, покращення координації роботи, контроль за ресурсами та фінансами, підвищення якості ветеринарного обслуговування та підтримку персоналу.
Метою курсової роботи є розробка комплексної системи, яка зберігає інформацію про тварин, їх план харчування, хвороби та медичні процедури, вольєри та умови в цих вольєрах, дані працівників, замовлення продуктів та розхідних матеріалів, наявність їх на складі та надає можливість керувати цими даними а також налаштовувати, аналізувати та відстежувати показники сенсорів в вольєрах в реальному часі.
Методи розробки базуються на технології ASP.NET 7, системи управління бази даних MS SQL Server 2019, веб-додаток базується на технології ASP.NET MVC, мобільний додаток – на технології SwiftUI, смарт-пристрій розроблено на платі Arduino ESP32, датчику вологості, температури та ваги за допомогою симулятора Arduino Wokwi та мови програмування C++.
У результаті роботи здійснено програмну реалізацію системи управління притулками для домашніх тварин і прототип розумних сенсорів для відстеження та розрахунку показників умов середовища в вольєрі тварини. Програмна система складається з веб-додатку, сервера, мобільного додатку та смартпристрою.
 
ЗМІСТ


ЗМІСТ	5
ВСТУП	7
1.	СПЕЦИФІКАЦІЯ СИСТЕМИ	8
1.1	Бізнес-вимоги	8
1.2	Концепція рішення	13
1.3	Рамки та обмеження	16
1.4	Бізнес-контекст	21
2	СЕРВЕРНА ЧАСТИНА	24
2.1	моделлювання програмної системи	24
2.2	моделлювання бази даних	25
2.3	Архітектура програмної системи	26
2.4	Програмна розробка системи	27
3	РОЗУМНИЙ ПРИСТРІЙ (ПРИСТРІЙ IOT)	31
3.1	моделлювання програмної системи	31
3.2	Взаємодія між частинами системи	32
3.3	Архітектура програмної системи	33
3.4	Програмна розробка системи	33
4	КЛІЄНТСЬКА ЧАСТИНА (ФРОНТЕНД ЧАСТИНА)	37
4.1	моделлювання програмної системи	37
4.2	Взаємодія між частинами системи	38
4.3	Архітектура програмної системи	38
4.4	Програмна розробка системи	39
5	МОБІЛЬНИЙ ЗАСТОСУНОК	43
5.1	моделлювання програмної системи	43
5.2	Взаємодія між частинами системи	43
5.3	Архітектура програмної системи	44
5.4	Програмна розробка системи	45
Висновки	49
Перелік посилань	50
Додаток А Схеми та діаграми	51
Додаток Б Приклади коду	71
Додаток В Перевірка на плагіат	81

 
ВСТУП


Область застосування результатів даної роботи широка та важлива для сучасного суспільства. Система управління притулками для тварин, розроблена в рамках цього проекту, може бути використана в будь-якому притулку для оптимізації рутинних завдань, покращення умов утримання тварин та підвищення ефективності роботи персоналу. Крім того, прототип розумних сенсорів, створений для відстеження умов середовища в вольєрах тварин, може бути використаний у будь-якому притулку для забезпечення комфорту та безпеки тварин.
Актуальність роботи полягає у тому, що проблема управління притулками для тварин та умов утримання бездомних тварин є актуальною для багатьох країн світу. Швидкий розвиток технологій та зростання обсягів безхатніх тварин створюють потребу у вдосконаленні систем управління та покращенні умов їх утримання. Така система може допомогти зменшити стрес для тварин, покращити їх умови утримання та зробити роботу притулків більш ефективною та продуктивною.
Мета завдання курсової роботи полягає в розробці та впровадженні комплексної системи управління притулками для тварин, яка забезпечує збереження та обробку інформації про тварин, покращить умови їх утримання, оптимізує робочі процеси та сприятиме збільшенню шансів тварин на адопцію. Така система дозволить ефективно керувати ресурсами притулку, покращить якість медичного обслуговування та сприятиме підвищенню ефективності роботи персоналу.
 
ОСНОВНА ЧАСТИНА
1.	СПЕЦИФІКАЦІЯ СИСТЕМИ
1.1	Бізнес-вимоги


В цьому підрозділі буде описано передумови створення проекту, бізнес можливості, а саме порівняння з аналогами, принципи монетизації, бізнес-цілі та критерії успіху, потреби клієнтів та ринку, ризики, які можуть перешкоджати створенню або роботі програмної системи. 


1.1.1 	 Передумови


Притулок для тварин – це місце, де бездомні тварини знаходять тимчасовий притулок та догляд. Однак, кількість таких тварин часто перевищує можливості притулків, що призводить до ряду суттєвих проблем. Нестача місць змушує тварин жити в тісних вольєрах, що негативно впливає на їх фізичний та психологічний стан. Наприклад, собаки можуть проводити більшу частину дня в обмежених просторах, що призводить до стресу та агресивної поведінки. Нестача коштів обмежує можливості притулків надавати якісне харчування та ветеринарне обслуговування. Часто тварини не отримують своєчасного лікування, що призводить до погіршення їх здоров’я. Дефіцит персоналу означає, що працівники перевантажені роботою, не мають достатньо часу для кожної тварини та можуть швидко вигоряти емоційно.
Соціальні аспекти також грають важливу роль у функціонуванні притулків. Відчуття відповідальності та емоційне вигорання персоналу – це серйозні проблеми, які впливають на якість догляду за тваринами. Більше того, проблема бездомних тварин впливає на місцеву спільноту. Погані умови утримання тварин можуть викликати занепокоєння у громадськості, знижуючи рівень довіри до притулків. Навпаки, добре керовані притулки можуть сприяти підвищенню усвідомлення суспільством проблем бездомних тварин та стимулювати громадськість до активної допомоги.
Система управління притулком автоматизує рутинні завдання, звільняючи час персоналу для піклування про тварин. Вона покращує координацію роботи, надаючи доступ до актуальної інформації про стан тварин, їх харчування та ветеринарне обслуговування. Це дозволяє створити комфортні умови утримання, що позитивно впливає на фізичний та емоційний стан тварин. В результаті, життя тварин у притулку стає кращим, а їх шанси знайти люблячий дім - вищими. 
Система управління притулком може допомогти вирішити описані проблеми через оптимізацію розміщення тварин, контроль за ресурсами та фінансами, підвищення якості ветеринарного обслуговування, підтримку персоналу та залучення громадськості.


1.1.2 Бізнес-можливості


Аналоги на ринку:
–	 ShelterPro: ShelterPro - це комплексне програмне забезпечення для управління притулком для тварин, яке включає ведення журналу обліку тварин, ветеринарне обслуговування, адопції та збір коштів. Це рішення пропонує широкий спектр функцій, але може бути дорогим для невеликих притулків. Крім того, ShelterPro має складний інтерфейс, що може ускладнити його використання для нових користувачів
–	PetPoint: PetPoint - це хмарне програмне забезпечення для управління притулком для тварин, яке відзначається простотою у використанні та доступною ціною. PetPoint також пропонує широкий спектр функцій, включаючи ведення журналу обліку тварин, ветеринарне обслуговування, адопції та збір коштів. Однак, PetPoint не має такого ж широкого функціоналу, як ShelterPro, і може бути недоступним у деяких країнах.
–	  The Rescue Network: The Rescue Network - це безкоштовне програмне забезпечення для управління притулком для тварин. Воно пропонує основні функції, такі як ведення журналу обліку тварин, ветеринарне обслуговування та адопції, і є простим у використанні. Проте, The Rescue Network не має такого ж широкого функціоналу та гнучкості, як ShelterPro або PetPoint.
Переваги продукту в порівнянні з наведеними вище аналогами на ринку полягають у зручності його використання завдяки наявності мобільного застосунку, який працює в режимі реального часу та надає актуальну інформацію. Наш продукт відзначається простотою та гнучкістю, що дозволяє адаптувати систему до потреб будь-якого притулку, незалежно від його розміру або розташування.
Монетизація системи відбувається через підписку на різний строк, що надає доступ до розширених можливостей. Також розглядаються альтернативні моделі монетизації, такі як оплата за використання, платіжні комісії та рекламні послуги, щоб забезпечити максимальну відповідність потребам ринку. Обрана модель підписки дозволяє притулкам отримувати доступ до необхідних функцій без значних одноразових витрат, що робить її ефективною та привабливою для більшості притулків.
Система призначена для притулків для тварин по всьому світу, які прагнуть покращити свою роботу та знайти більше домівок для тварин. Вона допомагає притулкам оптимізувати свої процеси, покращити умови утримання тварин та підвищити рівень усвідомлення суспільством проблем бездомних тварин.



1.1.3 	Бізнес-цілі та критерії успіху


З використанням продукту витрати на обслуговування та на утримання працівників знизяться на 20-30% за рік. Критерієм успіху є завантаження мобільного застосунку та реєстрація 100 тис користувачів та оформлення платної підписки 2 тис користувачів.


1.1.4 	Потреби клієнтів та ринку


а)  Потреби клієнтів:
1) 	Притулки для тварин: потребують ефективної системи для управління всіма аспектами своєї роботи, включаючи ведення журналу обліку тварин, ветеринарне обслуговування, адопції, збір коштів, маркетинг та багато іншого.
2) 	Персонал притулків: потребує інструменту, який допоможе їм економити час, краще організувати свою роботу та покращити догляд за тваринами.
3) 	Волонтери: потребують простого у використанні інструменту, щоб допомогти їм у своїх завданнях.
4) 	Потенційні власники тварин: потребують зручного способу пошуку та адопції тварин.
б)  Ринковий попит: Зростає потреба в більш ефективних та гуманних методах роботи притулків для тварин, в прозорості та підзвітності притулків для тварин, в кращому зв'язку та співпраці між притулками для тварин, рятувальними групами та громадськістю.
в) Невиконані потреби: 
1) 	Наявні системи управління притулками для тварин часто є дорогими, складними та застарілими.
2) 	Багато притулків для тварин не мають доступу до жодної системи управління.
3) 	Існує потреба в більш інтегрованому та всебічному підході до управління притулками для тварин.
г)  Сценарії використання:
1) 	Персонал притулку: використовує систему для ведення журналу обліку тварин, запису ветеринарних даних, відстеження адопцій, ведення звітності та багато іншого.
2) 	Волонтери: використовує систему для пошуку тварин, які потребують допомоги, для координації заходів та для спілкування з потенційними власниками тварин.
3) 	Потенційні власники тварин: використовує систему для пошуку тварин для адопції, для подання заявки на адопцію та для спілкування з притулком.


1.1.5 	Бізнес-ризики


–	Конкуренція: На ринку існують інші системи управління притулком для тварин. Ці системи можуть бути більш зрілими, мати більшу базу користувачів або пропонувати ширший спектр функцій. Важливо чітко визначити конкурентні переваги системи та розробити стратегію їх просування.
–	 Фінансування: Розробка та впровадження системи управління притулком для тварин може бути дорогим. Важливо знайти джерела фінансування для покриття цих витрат. Можливі джерела фінансування включають гранти, пожертви та інвестиції.
–	 Маркетинг: Важливо ефективно просувати систему притулкам для тварин. Це може включати створення вебсайту, проведення маркетингових кампаній та участь у торгових виставках.
–	Регулювання: Існують нормативні акти, які можуть впливати на розробку та впровадження системи управління притулком для тварин. Важливо дотримуватися цих нормативних актів. Недотримання нормативних актів може призвести до штрафів або інших санкцій.
–	 Прийняття: Не всі притулки для тварин можуть бути готові прийняти нову систему управління. Важливо їм продемонструвати, що система може допомогти їм покращити свою роботу.
–	 Зміна обставин: Зовнішні фактори, такі як економічні умови або зміни в законодавстві, можуть негативно вплинути на проект. Важливо регулярно оцінювати ризик та вживати заходів для його пом'якшення.


1.2	Концепція рішення


В цьому підрозділі буде окреслено концепцію програмної системи, а саме мета, завдання програмної системи, головна функціональність, припущення та залежності. 


1.2.1 	 Окреслення концепції


Мета проекту з притулком для тварин полягає в створенні комплексної системи управління, яка забезпечить ефективний догляд за тваринами та оптимізує робочі процеси притулку. Головною метою є забезпечення кращого життя для тварин шляхом забезпечення відповідного догляду, медичної допомоги та швидкого розміщення в нових домівках.
Досягнення цієї мети передбачає забезпечення відповідного догляду за тваринами у притулку, надання доступу до актуальних медичних даних та історій тварин, забезпечення ефективного взаємозв'язку між працівниками притулку та іншими зацікавленими сторонами, підвищення шансів на адопцію тварин шляхом прискорення процесу знаходження їм нових домівок, покращення умов притулку за допомогою моніторингу та аналізу даних, а також забезпечення прозорості та ефективного управління ресурсами притулку.
Цільові завдання програмної системи включають реєстрацію та ідентифікацію тварин, ведення актуального обліку медичної інформації та процесів лікування, створення ефективної бази даних для швидкого пошуку та знаходження історій тварин, а також підтримку комунікації з потенційними власниками.
Програмна система притулку для тварин буде використовуватися для досягнення цих цілей шляхом створення інтуїтивного і легкодоступного інтерфейсу для персоналу притулку та потенційних адоптуючих. Працівники притулку зможуть легко реєструвати нових тварин, вносити та оновлювати їхні медичні дані, розміщувати фотографії тварин для адопції та вести взаємодію з потенційними власниками через веб-портал або мобільний додаток.


1.2.2	       Головна функціональність


Головна функціональність включає в себе:
MF1.	Автоматизований моніторинг:
1)	Система автоматично відстежує рівень води та корму у годівницях та поїлках, вологість та температуру в вольєрах. Датчики автоматично передають дані на сервер, де вони обробляються та аналізуються.
2)	Система надсилає сповіщення персоналу притулку, коли рівень води або корму стає низьким, або коли показники температури чи вологості виходять за допустимі межі.
3)	Система гарантує резервне копіювання всіх наявних даних, щоб уникнути втрати інформації в разі збоїв або аварійних ситуацій.
MF2.	Персоналізовані профілі тварин:
1)	Кожна тварина має свій профіль, де міститься інформація про її вид, вік, стать, особливості догляду, медичну історію та фото. Ця функція доступна як на веб-сайті, так і в мобільному додатку, забезпечуючи зручний доступ для користувачів з різних пристроїв.
2)	Система дозволяє відстежувати стан здоров'я тварин, а також ветеринарні обстеження та щеплення.
3)	Система забезпечує конфіденційність та безпеку даних тварин та працівників. Доступ до інформації про тварин мають лише авторизовані користувачі з відповідним рівнем доступу.
MF4.  Адміністрування системи:
1)	Ролі адміністратора, логіста та ветеринара в клієнтській та мобільній частині з різним функціоналом та рівнем доступу до управління притулком;
2)	Можливість використання різних датчиків у пристрої IoT.
MF5. Безпека: Система забезпечує конфіденційність та безпеку даних тварин. Доступ до інформації про тварин мають лише авторизовані користувачі з відповідним рівнем доступу.
MF6. Локалізація та мовна підтримка: Система, зокрема веб та мобільна частини, підтримує англійську та українську мови для зручного використання користувачами з різних країн.
2.3	    Припущення та залежності


а) Припущення:
–	Притулок має доступ до Інтернету та комп'ютерів.
–	Персонал притулку має базові знання про використання комп'ютерів.
–	Притулок має Wi-Fi покриття для мобільних пристроїв.
–	Пристрій IoT буде сумісний з Wi-Fi мережею притулку.
б) Залежності:
–	Проект залежить від наявності та доступності сучасних пристроїв IoT для відстеження харчування.
–	Проект залежить від надійного постачання електроенергії для роботи пристроїв IoT.
–	Проект залежить від розробників програмного забезпечення для розробки та підтримки веб- та мобільних додатків.
–	Проект залежить від постачальників хмарних сервісів для зберігання даних.
–	Проект залежить від співпраці з притулками для тварин для тестування та вдосконалення системи.


1.3	Рамки та обмеження


В цьому розділі описано рамки первинного випуску для кожної із частин системи, додаткові відомості про систему, рамки наступних випусків, обмеження.


1.3.1	Рамки первинного випуску


Проект передбачає створення програмного продукту для ефективного управління притулком для тварин, доступного як у веб-середовищі, так і на мобільних пристроях. Перший випуск програми має наступний функціонал:
а) Серверна частина: 
–	Зберігання даних: інформація про тварин (фото, кличка, вид, вік, стать, стан здоров'я, історія), про персонал (контактна інформація, посада, відповідальність); відомості про запаси (корм, вода, медикаменти, інші ресурси), історія подій (ветеринарні обстеження, щеплення, замовлення).
–	Обробка даних з датчиків: збір даних з IoT-пристроїв (рівень води та корму, температура, вологість), аналіз даних для виявлення проблем (низький рівень води/корму, відхилення температури/вологості).
–	Надсилання сповіщень: оповіщення персоналу про порушення умов утримання тварин, про потребу в поповненні запасів.
б) Веб-додаток:
–	Інтерфейс для адміністратора: перегляд та редагування інформації про тварин, персонал, запаси, налаштування системи (користувачі, датчики, IoT-пристрої), надання та зміна ролей в системі для працівників, створення резервної копії бази даних.
–	Інтерфейс для ветеринара: перегляд та редагування даних про стан тварин, додавання інформації про ветеринарні обстеження, щеплення, проведені процедури, створення та ведення медичних карток тварин, аналіз даних про стан здоров'я тварин.
–	Інтерфейс для логіста: контроль рівня запасів (корм, вода, медикаменти, інші ресурси), створення замовлень на поповнення запасів, аналітика даних про запаси.
в) Мобільний додаток:
–	Перегляд інформації: детальна інформація про кожну тварину (фото, кличка, вид, вік, стать, особливості догляду, стан здоров'я, історія), список завдань для персоналу, історія виконаних завдань, отримання сповіщень про порушення умов утримання.
–	Виконання завдань: годування тварин з можливістю встановлення часу годування та кількості корму, ведення записів про стан тварин (спостереження, симптоми, ветеринарні обстеження).
–	Створення та редагування записів: додавання інформації про ветеринарні обстеження, щеплення, проведені процедури, редагування даних про стан тварин, оновлення інформації.
г) Пристрій IoT:
–	Відстеження рівня води та корму: датчики в годівницях та поїлках будуть постійно моніторити рівень води та корму, ці дані будуть передаватися на серверну частину системи зі вказаною користувачем частотою.
–	Контроль температури та вологості: датчики в приміщеннях притулку будуть постійно вимірювати температуру та вологість, дані про це будуть передаватися на серверну частину системи.
–	Математична обробка даних: обчислення індексу теплового стресу, середнього споживання води,  прогнозування рівня води на наступний день в залежності від температури.
Також для веб та мобільного застосунку передбачається локалізація та мовна підтримка: система повинна підтримувати різні мови (англійська та українська) для зручного використання користувачами з різних країн. У всій системі буде діяти захист персональних даних, тобто всі особисті дані користувачів повинні будуть зберігатися в зашифрованому вигляді, забезпечуючи їх конфіденційність та безпеку. 
Система матиме чітко визначені ролі користувачів з різними рівнями доступу. Це дозволить забезпечити безпеку та запобігти несанкціонованому використанню даних. 
Також при авторизації буде використовувати JWT-токен, за допомогою якого будуть робитися запити на сервер, і відповідно, надавати певний рівень доступу до певного функціонала на серверній частині.


1.3.2	   Рамки наступних випусків


У наступних випусках продукту планується впровадження додаткових функцій, спрямованих на поліпшення користувацького досвіду та збільшення можливостей для користувачів:
–	Впровадження функціонали для адопції тварин.
–	Розробка модулів для аналізу даних про стан здоров'я тварин та виявлення відхилень за допомогою штучного інтелекту.
–	Інтеграція з системами електронного документообігу для автоматизації ведення медичних карток тварин та звітності.
–	Додавання можливостей для онлайн-консультацій з ветеринарами та спеціалістами з догляду за тваринами.
–	Розширення функціоналу для спільного ведення журналів та обміну інформацією між персоналом притулку.
–	Впровадження системи сповіщень про надходження нових тварин або змін у їхньому стані для волонтерів та потенційних власників.
–	Розробка інтелектуальних алгоритмів для оптимізації споживання ресурсів (корму, води) з урахуванням індивідуальних потреб тварин.
–	Додавання можливостей для взаємодії з іншими пристроями в притулку (наприклад, системами безпеки або освітлення) для автоматичного реагування на зміни у середовищі.
–	Розширення функціоналу для аналізу ефективності роботи притулку та прогнозування потреб у ресурсах.
–	Впровадження системи генерації рекомендацій щодо оптимізації умов утримання тварин на основі аналізу даних.
–	Розробка механізмів для захисту від кібератак та несанкціонованого доступу до системи.


1.3.3    Обмеження та Виключення


У новому продукті існують певні обмеження та виключення, які можуть впливати на його роботу та експлуатацію. Ці обмеження та виключення важливо враховувати для коректної роботи системи та задоволення потреб користувачів. Нижче деякі з них:
–	Обмежене Інтернет-з'єднання: Для правильної роботи продукту необхідне стабільне Інтернет-з'єднання. Відсутність Інтернет-з'єднання може призвести до некоректної роботи деяких функцій, зокрема отримання оновлень та сповіщень. 
–	Підтримка обладнання: Продукт підтримує лише певні типи датчиків та обладнання. Деяке стороннє обладнання може бути несумісним з системою та, отже, не може бути перераховані інтегроване.
–	Доступність інтерфейсу: Інтерфейс продукту може бути недоступний для деяких користувачів з обмеженими можливостями.
–	Конфіденційність та захист даних: Хоча робиться все можливе для забезпечення конфіденційності користувачів, неможливо гарантувати абсолютну безпеку даних через Інтернет. Інформація, яка передається через систему, може бути піддана ризику злому.
Ці обмеження важливі для знання користувачами та операторами системи, щоб уникати непорозумінь та забезпечити оптимальну роботу продукту в умовах реальної експлуатації.


1.4	Бізнес-контекст


В цьому підрозділі описано профілі зацікавлених сторін та причини їх зацікавленості, пріоритети проекту, робоче середовище, а саме технології, що використовувались при розробці.


1.4.1	    Профілі зацікавлених сторін


На таблиці 1.4.1 описані профілі зацікавлених сторін:

Таблиця 1.4.1 – Профілі зацікавлених сторін 
Ветеринари	Кращий контроль за здоров'ям тварин, раннє виявлення проблем	Зацікавлені, якщо система допоможе їм краще піклуватися про здоров'я тварин	Доступ до інформації про тварин та їхню медичну історію, ведення записів про огляди, щеплення та лікування	Необхідність навчання, ризик відторгнення нової системи
Власники тварин	Можливість знайти та адоптувати тварину	Зацікавлені, якщо система полегшить їм пошук та адопцію тварини	Зручний пошук тварин, подання заявки на адопцію, спілкування з притулком	Необхідність доступу до мобільного пристрою та Інтернету

Кінець таблиці 1.4.1
Притулки для тварин	Кращий догляд за тваринами, економія часу та коштів, підвищення прозорості 	Зацікавлені, якщо система допоможе їм краще піклуватися про тварин, економити час та кошти	Відстеження тварин, управління запасами, ведення журналу обліку	Обмежений бюджет, доступ до Інтернету та комп'ютерів, знання персоналу
Персонал притулку	Ефективне виконання завдань, покращення умов праці	Зацікавлені, якщо система полегшить їхню роботу	Простий у використанні інтерфейс, доступ до інформації про тварин та завдання	Необхідність навчання, ризик відторгнення нової системи


1.4.2	   Пріоритети проєкту


На таблиці 1.4.2 наведені основні пріоритети проекту:

Таблиця 1.4.2 – Основні пріоритети проєкту 
Показник	Опис	Пріоритет
План робіт	Реліз версії 1.0 повинен бути доступний до 07.06.2024	Високий
Функціональність	Наявність всього зазначеного функціоналу версії 1.1	Високий
Якість	Система повинна бути стабільною, працювати без збоїв, бути доступною в будь-який час.	Високий
Персонал	Розмір команди – 1 людина	Середній
Ціна	Обмежений бюджет, з можливістю перевищення до 15%	Середній

1.4.3	   Робоче середовище


У проекті будуть використовуватися ряд технологій та програмних засобів для забезпечення надійності, продуктивності та доступності. Основні компоненти нашого робочого середовища виглядають так:
–	 Мова програмування: Система буде розроблена за допомогою C#. Вибір C# обґрунтований його швидкодією та ефективністю, а також широким спектром доступних інструментів та бібліотек для розробки програмного забезпечення.
–	База даних: буде використовуватися Microsoft SQL Server в якості як система управління базами даних та її база даних. Це забезпечить надійне зберігання даних та швидкий доступ до них.
–	Фреймворк та інтерфейс: Для розробки серверної частини буде використовуватися ASP.NET. Цей фреймворк гарантує швидку та надійну роботу системи. Для веб-версії застосунку планується використання HTML5, Bootstrap і JavaScript для забезпечення інтерактивності та зручного користувацького інтерфейсу.
–	Мобільний застосунок: Для мобільної версії застосунку, що буде розроблений під операційну систему IOS, буде використовуватися мова Swift та SwiftUI.
–	Пристрій IoT: Для його розробки буде використовуватися платформа Arduino: Датчики для температури та вологості DHT22, датчик рівню води та тензодатчик (вага), мікроконтролер ESP32, запрограмований на мові С,  для виходу в Інтернет та досягнення Back-end частини.
–	Забезпечення безпеки: Планується використання протоколу HTTPS для забезпечення шифрування даних під час передачі, а також впровадження використання JWT-токенів для надання доступу до певних даних при авторизації.
–	Створення резервної копії бази даних у вигляді файлу формату .bak з усіма наявними даними системи.
2	СЕРВЕРНА ЧАСТИНА
2.1	моделлювання програмної системи


Для розгляду функціональності було створено декілька Use-Case діаграм для різних ролей системи. 
В системі взагалі є декілька ролей: адміністратор (директор), лікар, відповідальний за постачання. Функціонал адміністратора включає доступ до всіх можливостей інших ролей та управління персоналом (додаток А, рис. А.1). Він також має повний доступ до бази даних та найвищі права для роботи з нею, тобто створювати, редагувати, видаляти (однак не може видалити саму базу даних) таблиці, дані, може додавати нових користувачів.
Далі можна розглянути Use-Case діаграму для лікаря (наведено у додатку А, рис А.2). На діаграмі можна побачити одного діючого актора – лікаря, що має можливість керувати хворобами та медичними процедурами тварини, вказувати розхідні матеріали для процедур, розраховувати та змінювати план харчування тварин та оновлювати інформацію про тварину.
Роль відповідального за постачання включає в себе оформлення замовлень та поповнення вольєрів. Цей функціонал наведено на Use-Case діаграмі 3 (додаток А, рис А.3). 
Для моделлювання бізнес-процесів та опису послідовності дій користувача з різними ролями було створено декілька діаграм активності. Розглянемо першу діаграму активності дій з працівниками (додаток А,  рис А.4). На цій діаграмі наведено можливі функції та дії адміна (директора) з працівниками: перегляд даних працівника, зміна ролі. Для всіх змін адміністратору необхідно підтверджувати особистість за допомогою вводу паролю та пройти перевірку на рівень доступу.
Лікар може переглядати медичну картку тварини, додавати нові дані про хвороби, відповідні до них медичні процедури та розхідні матеріали цих процедур. Цей функціонал можна подивитися на діаграмі активності для дій лікаря з хворобами (додаток А, рис А.5).
Одна з основних функціональностей зосереджена у діях користувача з тваринами. Користувач може переглядати список наявних тварин або приймати нових, переглядати детальну інформацію про них, редагувати її, поміщати або переміщувати у вольєр,  виставляти необхідні умови для вольєру, переглядати дані, надані сенсором щодо деяких показників (температура, вологість, прогнозування, рівень води та їжі), видаляти тварин. Це можна побачити на наведеній діаграмі активності щодо дій з тваринами (додаток А, рис А.6).


2.2	моделлювання бази даних


Проаналізувавши функціонал системи, можна визначити декілька основних об’єктів системи, а саме: працівник, його завдання, тварини, їх раціон їжі, їх хвороби та медичні процедури, вольєр та його умови, поповнення вольєру, сенсор та дані сенсору, сховище та замовлення на покупку, а також визначити логічні зв’язки між ними: у тварини може бути декілька прийманнь їжі, декілька хвороб та медичних процедур, один вольєр, у вольєра один сенсор, одна умова та безліч поповнень,  у сенсора може бути безліч даних, тобто тих, що надсилає пристрій IoT, у медичних процедур будь скільки розхідних матеріалів. У працівника може бути будь-яка кількість завдань та замовлень. На основі цих даних була побудована ER-діаграма (додаток А, рис А.7) з декількома видів зв’язків: один-до-багатьох (тварина-хвороба, тварина-мед процедура, тварина - приймання їжі, процедура-матеріали, сенсор-дані сенсора, вольєр-поповнення вольєру, працівник-завдання, працівник-замовлення), один-до-одного (вольєр-умови, користувач-працівник).


2.3	Архітектура програмної системи


Серверна частина розроблена з використанням технології ASP.Net Core. Демонстрація працездатності та тестування виконується за допомогою OpenApi (Swagger), що стоїть по замовченню при розробці проекту Web Api ASP.Net Core у Visual Studio 2022.
Серверна частина використовує захищений протокол HTTPS, базу даних Azure SQL. База даних та серверна частина розвернута на сервісі Azure. Система використовує модель клієнт-сервер: сервер надає послуги кільком клієнтам, які в свою чергу ініціюють запити серверу.
Система працює через HTTP запити для виконання стандартних функцій бази даних (створення, видалення, читання, редагування): GET-метод для отримання інформації, DELETE-метод для видалення запису, POST-метод для створення нового запису, PUT-метод для оновлення запису в базі даних. Серверна частина повертає відповідь на запити в форматі JSON та коди відповіді (200 – успіх, 400 – незрозумілий запит, 404 – не знайдено, 500 – неможливість обробки сервером). Специфікація наведена у додатку Б.
Принцип взаємодії серверної частини з іншими частинами системи наведено на діаграмі розгортання (додаток А, рис А8). На ній можна подивитися, як частини всього проекту взаємодіють між собою, які технології та протоколи використовуються.


2.4	Програмна розробка системи


На основі ER-діаграми були створені класи-моделі у програмі (наведено 1 клас як приклад, інші моделі створені таким же чином):

1	namespace SmartShelter_WebApi.Models
2	{
3	    public class Aviary
4	    {
5	        public int Id { get; set; }
6	        public string? Description { get; set; }
7	        public int? AnimalId { get; set; }
8	        public int? AviaryConditionId { get; set; }
9	
10	
11	        public Animal Animal { get; set; }
12	        public AviaryCondition AviaryCondition { get; set; }
13	     }
14	}

В наведеному коді можна побачити відповідні поля, які є і в ER-діаграмі, а також поля (рядки 7-8, 11-12) для створення зв’язків у технології Entity Framework Core.
Для всіх об’єктів використовувалась наступна технологія розробки функціональності: створювався інтерфейс, в якому були необхідні методи для роботи з базою даних, далі створювався сервіс, в якому ці методи реалізовувалися. Цей сервіс використовувався у відповідних контролерах, в яких знаходились основні методи для http-запитів (get, post, put, delete) та налаштовувалась маршрутизація. Також використовувався AutoMapper для сворення об’єкту передачі даних (data transfer object - DTO) для того, щоб не передавати непотрібну для загального користування або конфіденційну інформацію користувачеві.
Всі об’єкти, які представляють собою таблиці бази даних, знаходяться в класі DataContext. В цьому класі в якості полей і є об’єкти таблиць, також є метод для створення цих таблиць, створення зв’язків між ними, заповнення початковими даними. Екземпляр цього об’єкту буде використовуватись в реалізаціях сервісів кожної моделі.
Далі для прикладу буде наводитись частина коду сервісу тварин. Інтерфейс з методами для тварин (IAnimalService):

1	public interface IAnimalService
2	    {
3	        public List<Animal> GetAll();
4	        public Animal? GetById(int id);
5	        public bool AddAnimal(AddAnimalDto animalDto);
6     	 Jgh    public bool RemoveAnimal(int id);

Реалізація інтерфейсу IAnimalService (AnimalService) наведена в додатку Б. В рядках 11-14 наводиться метод отримання всіх тварин. В рядках 16-20 наводиться метод отримання тварини по її ідентифікатору. В рядках 21-27 наведено метод для додавання тварини, в якому за допомогою AutoMapper з об’єкту DTO утворюється об’єкт тварини, що зберігається в базі даних. В рядках 28-39 наведено метод для видалення тварини та її хвороби. 
Далі будуть наведені  декілька реалізацій особливих методів, які відносяться до конкретних об’єктів.
Клас вольєру AviaryService: метод для отримання поповнень вольєру по Id:

1	public List<AviaryRecharge>? GetAllRecharges(int id)
2	{
3	   var recharges = _dbContext.AviariesRecharges.Where(x=> x.AviaryId == id).ToList();
4	   return recharges;
5	}

Клас працівників StaffService: метод для отримання даних працівника по його Id, які надаються тільки про себе, або для адміна - всі:

1 public async Task<StaffDto?> GetById(int id, string senderUsername)
2 {
3	 var userId = GetIdentityId(id);
4	 if (userId.IsNullOrEmpty())
5	 {
6	                return null;
7	 }
8	 if (await CheckAccess(userId, "", senderUsername))
9	 {
10	    var user = _dbContext.Staff.FirstOrDefault(x => x.Id == id);
11	    var mappedUser = _mapper.Map<StaffDto>(user);
12	    return mappedUser;
13	 }
14	 return null;
15 }

Клас вольєру AviaryService, в якому при зміні місця розташування тварини, перевіряється, чи немає в новому вольєрі іншої тварини, далі тварина переміщується в новий вольєр, а старий звільняється:

1 public bool ChangeAviary(int animalId, int newAviaryId)
2 {
3	var oldAviary = _dbContext.Aviaries.FirstOrDefault(x => x.AnimalId == animalId);
4	if (oldAviary != null)
5	{
6		oldAviary.AnimalId = null;
7	     _dbContext.Update(oldAviary);
8	}
9	var newAviary = _dbContext.Aviaries.FirstOrDefault(x => x.Id == newAviaryId);
10	if (newAviary != null && newAviary.AnimalId == null)
11	{
12	    newAviary.AnimalId = animalId;
13	}
14	else
15	{
16	    return false;
17	}
18	   return Save();
19 }

Спеціальний клас для авторизації та реєстрації AuthService, що використовує вбудовані механізми .Net Identity для реалізації входу та реєстрації. Наведено метод реєстрації нового користувача:
1	public async Task<bool> RegisterUser(LoginUser user)
2	{
3	   var identityUser = new IdentityUser
4	     {
5	          UserName = user.Username,
6	          Email = user.Username
7	     };
8	            
9	    var result = await  _userManager.CreateAsync(identityUser, user.Password);
10	     return result.Succeeded;
11	}
	
Всі методи репозиторіїв використовуються, відповідно, контролерах, в  яких реалізовано основні методи API (HTTP-запити): get, put, post, delete. 
Важливо звернути увагу на метод, який потрібен для аналізу показників сенсора (наведено в додатку Б). Цей метод використовується для обробки даних і надсилання повідомлень користувачу на електронну пошту. В рядках 3-11 перевіряється існування сенсору та вольєру, до якого прив’язані дані, потім з бази даних обирається умова рослини (рядок 9), якщо вона існує, то отримані від сенсора дані звіряються з цими умовами, та в процесі складається в строку відхилення від умов (рядки 19-70). Якщо відхилення було знайдено, то з бази даних береться користувач (рядок 77) та на його електронну пошту надсилається лист (рядки 78-82). Також окремим методом перевіряється кількість їжі у вольєрі  відповідно до плану харчування тварини.


 
3	   РОЗУМНИЙ ПРИСТРІЙ (ПРИСТРІЙ IOT)
3.1	моделлювання програмної системи


Для розгляду функціональності було створено декілька Use-Case діаграм для різних ролей системи. Є 2 ролі: сам сенсор (його функціонал) та роль користувача системи, що може адмініструвати IoT пристрій. Для розгляду функціональності самого програмного забезпечення наведено Use-Case діаграму (додаток А, рис. А.9). На ній можна побачити, що сенсор має обчислювальну функціональність (обчислення індексу теплового стресу та прогнозування вживання води), функціонал для взаємодії з серверною частиною (функції для POST та GET запитів), які в тому числі використовуються для адміністрування (частоти відправки даних), функціонал для вибору підключеного датчика, функція для отримання часу в універсальному форматі UTC, метод для повідомлення користувача про критичні показники. 
У працівника притулку є доступ до системи за допомогою мобільного або веб додатку, є можливість адміністрування сенсору. Це відображено на Use-Case діаграмі 2 (додаток А, рис. А.10), а саме: перегляд даних сенсору, встановлення частоти надсилання даних. 
Повний цикл роботи системи можна описати наступним чином:
а) Користувач при першому використанні системи повинен локально підключитися до контролеру для налаштувань мережі. 
б)  Після підключення до мережі система робить запит до серверної частини для отримання частоти надсилання даних. Якщо не вдається встановити зв’язок з сервером, то буде використовуватися частота за замовченням – 1 година. Весь етап налаштувань можна розглянути на діаграмі активності (додаток А, рис. А.11).
в)  Починається функціонал, що буде відтворюватись з частотою 5 хвилин. До цього входить: отримання даних з сенсорів, розрахунок індексу теплового стресу та прогнозування, отримання часу в форматі UTC, а надсилання даних на сервер відбувається з отриманою частотою з серверу. 
г) При отриманні та обробці даних спочатку отримуються показники сенсору, температура в градусах Цельсія, відносна вологість у відсотках, маса води та їжі у грамах. На основі цих даних розраховується індекс теплового стресу, що  використовується для оцінки ризику теплового стресу у тварин та прогнозування вживання води, що є коефіцієнтом, який залежить від температури.
д) Якщо при ітерації вирахований на основі нових даних індекс теплового стресу буде високий, то надсилається запит на сервер з цим індексом для обробки, а також при високих або низьких показниках температури або вологості внепланово будуть надсилатися дані на сервер для додаткової перевірки. Весь процес обробки даних наведено на діаграмі активності (додаток А, рис. А.12).
е) Отримані та оброблені дані надсилаються на серверну частину з частотою, вказаною користувачем, але самі дані з сенсорів отримуються та перевіряються кожні 5 хвилин. Цикл повторюється, поки систему не буде відключено від живлення.


3.2	Взаємодія між частинами системи


Взаємодія програмного забезпечення з іншими частинами системи буде відбуватися через серверну частину, до якої було додано додаткові методи: отримання інформації про частоту надсилання даних та зміни цієї частоти (за замовчуванням складає 1 годину), метод для надсилання повідомлення користувачу про критичні показники (досягнення умов завищених або занижених температури або вологості, високого індексу теплового стресу). 
В якості прикладу взаємодії було створено діаграму взаємодії на основі діаграми активності щодо обробки даних (додаток А, рис. А.13). На цій діаграмі можна докладніше поглянути на послідовність дій самої програми та як відбувається взаємодія з серверною частиною.


3.3	Архітектура програмної системи


Програмне забезпечення для пристрою IoT було розроблено на мові програмування С++ у симуляторі Wokwi. Для відтворення фізичної системи було використано мікроконтролер Arduino ESP32, які має можливість підключення до мережі та виходу в Інтернет, що необхідно для взаємодії з серверною частиною, сенсор DHT22 для підрахунку вологості та температури, аналоговий сенсор температури NTC для демонстрації можливості підключення різного обладнання до системи, а також потенціометри для регулювання та встановлення кількості їжі та води (функціонал симулятора обмежений та немає сенсорів для вимірювання ваги). 
В програмі використовуються HTTP-запити для взаємодії з серверною частиною, бібліотеки HTTpClient для реалізації запитів, NTCClient для роботи з часом, ArduinoJson для обробки відповіді з серверної частини.


3.4	Програмна розробка системи


Перед початком написання коду було створено схему для фізичного розміщення частин системи: контролера та сенсорів (додаток А, рис. А.14).
Принцип підключення до контролера наступний: якщо сенсор DHT22 буде використовуватися для виміру і температури, і вологості, то його необхідно підключати до піна D15, якщо ж для виміру температури буде використовуватися інший сенсор, то DHT22 необхідно підключати до піна D18 (всі підключення відбуваються з виходу SDA). Інші виходи сенсора потрібно підключати так: VCC до 3V3, GND до GND. Також сенсори для води та їжі, потенціометри, що замінюють сенсори вимірювання маси в симуляторі, підключаються до пінів для вхідних даних, тобто D34 та D35.
В якості альтернативного сенсора для вимірювання температури використовується аналоговий сенсор NTC, який необхідно підключити до піна D39 (VN), всі інші підключення – аналогічно до сенсору DHT22.  
Після створення схеми починається написання коду. Спочатку оголошуються глобальні змінні, що повинні бути доступні в усіх методах програми. Це змінні показників сенсорів та розраховуємих показників, номери пінів, параметри мережі, частота, HTTP та NTP клієнти, адреса серверної частини. 
В методі setup() відбувається налаштування системи. Спочатку аналізуються піни та чи підключені до них датчики, після чого починаються спроби підключитися до мережі.
1	void setup() {
2	  Serial.begin(9600);
3	
4	  if(digitalRead(DHT_PIN_Hum) == HIGH){
5	    analogReadResolution(10);
6	    pinMode(NTC_PIN,INPUT);
7	    isNTC = 1;
8	    DHT_PIN = DHT_PIN_Hum;
9	    Serial.println("NTC is connected!");
10	  }
11	  dhtSensor.setup(DHT_PIN, DHTesp::DHT22);

 Як можна побачити, у строках 4-9 обирається сенсор, який буде використовуватися для виміру температури. Сенсор DHT22 підключається в будь-якому випадку (рядок 11), тому що в симуляторі, який використовується, не має інших сенсорів для виміру вологості.
Сенсор не почне працювати, поки не зможе підключитися до мережі.

12	 Serial.begin(115200);
13	  pinMode(WATER_PIN, INPUT);
14	  pinMode(FOOD_PIN, INPUT);
15	  Serial.print("Connecting to WiFi");
16	  WiFi.begin(SSID, Password);
17	  while (WiFi.status() != WL_CONNECTED) {
18	    delay(100);
19	    Serial.print(".");
20	  }
21	  Serial.println(" Connected!");
22	  Serial.print("OK! IP=");
23	  Serial.println(WiFi.localIP());
24	  
25	  getDataFrequency();
26	  timeClient.begin();
27	  timeClient.setTimeOffset(0);
28	}

У рядках 13-14 підключаються сенсори для води та їжі, далі у 15-19 відбувається підключення до мережі кожні 100 мілісекунд. Сенсор не почне працювати, поки не створиться з’єднання. 
Після підключення починається робота з сервером: сенсор запитує дані про частоту надсилання даних (рядок 25). Наприкінці методу запускається NTP клієнт для роботи з часом в формати UTC (рядки 26-27). Докладний процес налаштування також наведено на діаграмі станів (додаток А, рис. А.15).
Весь функціонал в методі loop() буде відбуватися доти, поки контролер не буде вимкнено, з частотою 5 хвилин, а дані будуть надсилатися на сервер з частотою, що була отримана від серверної частини. Спочатку викликається метод для отримання даних сенсора. Також в цьому методі аналізуються отримані дані та викликається метод для відправки повідомлення користувачу. Якщо пройшов час, частота, отримана з серверу, то при цій ітерації викликається метод sendPostRequest(), який використовується для відправки розрахованих та оброблених даних на сервер. Наприкінці викликається метод delay(), в який передається частота повторень циклу.
 Код методу sendPostRequest() наведено в додатку Б. В строках 5-6 створюється адреса, по якій необхідно робити POST-запит, у рядку 7 запускається HTTP-клієнт по цій адресі. Створюється JSON об’єкт  у вигляді строки з усіма зібраними та розрахованими даними (рядки 8-18), після чого відправляється запит (рядок 19). Після чого у рядках 20-27 оброблюється відповідь сервера.
 
4	   КЛІЄНТСЬКА ЧАСТИНА (ФРОНТЕНД ЧАСТИНА)
4.1	моделлювання програмної системи


Для розгляду функціональності було створено декілька Use-Case діаграм для різних ролей системи. 
В системі взагалі є декілька ролей: адміністратор (директор), лікар, відповідальний за постачання. Функціонал адміністратора включає доступ до всіх можливостей інших ролей та управління персоналом (наведено на Use-Case діаграмі 2, рис. А.16). Він також має повний доступ до бази даних та найвищі права для роботи з нею, тобто створювати, редагувати, видаляти (однак не може видалити саму базу даних) таблиці, дані, може додавати нових користувачів, створювати резервну копію бази даних.
Далі можна розглянути Use-Case діаграму для лікаря (наведено у додатку А, рис А.17). На діаграмі можна побачити одного діючого актора – лікаря, що має можливість керувати хворобами та медичними процедурами тварини, вказувати розхідні матеріали для процедур, розраховувати та змінювати план харчування тварин та оновлювати інформацію про тварину. 
Роль відповідального за постачання включає в себе оформлення замовлень та поповнення вольєрів. Цей функціонал наведено на Use-Case діаграмі 3 (додаток А, рис А.18). 
Також функціонал адміністратора та послідовність його дій з тваринами можна побачити на діаграмі активності (додаток А, рис А.19). На цій діаграмі наведено можливі функції та дії адміна (директора) з тваринами: перегляд даних тварини, редагування, додавання та видалення планів харчування, хвороб, процедур, розхідних матеріалів. Для всіх змін адміністратору необхідно підтверджувати особистість за допомогою вводу паролю та пройти перевірку на рівень доступу.
4.2	Взаємодія між частинами системи


Взаємодія клієнтської частини з іншими частинами системи буде відбуватися через серверну частину, до якої будуть робитися HTTP-запити, а саме: GET, POST, PUT, DELETE. З серверної частини можуть повертатися дані у різному форматі: об’єкти – у JSON форматі, в якій серіалізуються отримані з бази даних об’єкти, повідомлення про успішне створення, редагування, видалення, оновлення даних – за допомогою різних кодів (основні – 401, 400, 404, 200, 500).  
В якості прикладу взаємодії було створено діаграму взаємодії на роботи адміністратора з працівниками(додаток А, рис. А.20). На цій діаграмі можна докладніше поглянути на послідовність дій самої програми та як відбувається взаємодія з серверною частиною.


4.3	Архітектура програмної системи


Клієнтська частина була розроблена на мові програмування С# за використанням технології розробки  ASP .NET MVC. В якості моделі в цій архітектури виступають класи, яки використовувались  у серверверній частини, тобто класи об’єктів (тварина, вольєр, сенсор, користувач і т. д.) та класи для обмеженого перегляду інформації, тобто класи DTO (data transfer object), які містять не всі поля класу, а тільки ті, що не містять вразливої інформації. Об’єкти DTO отримуються з сервера або передаються на нього (наприклад, при реєстрації та авторизації, отримання даних про працівників). В якості вида-сторінки (View) використовуються стандартні елементи – файли, в яких об’єднано HTML та C#, з розширенням .cshtml. Також для реалізації дизайну використовується бібліотека bootstrap. В якості контролера виступають класи-контролери, тобто файли з C# кодом, які використовуються для створення та відкриття сторінок, збирання даних з форм (POST-методи), асинхронних запитів до серверної частини програмної системи. В системі реалізовано локалізацію англійською та українською, тобто змінюється мова інтерфейсу, формат дати, сама дата (при англійській – в форматі UTC, при український – час за Києвом), для чого до кожної сторінки сайту додано 2 файли ресурсів, в яких у вигляді ключа-значення знаходиться текст, що використовується на сторінках. Локалізація змінюється за допомогою списку, що випадає, у заголовку кожної сторінки, з якого можна обрати необхідну мову.
Клієнтська частина взаємодіє з серверною за допомогою HTTP-запитів (GET, POST, PUT, DELETE).


4.4	Програмна розробка системи


Для організації додатку використовується стандартний шаблон для ASP .NET Web додатку, тобто папки контролерів, сторінок, ресурсів (для локалізації), моделей (класи об’єктів, що зберігаються у базі даних), View-моделей (класи, що використовуються у відображенні даних на сторінках), DTO для відправки або отримання даних серверу.
Для візуалізації взаємодії моделей (класів) між собою було розроблено діаграму компонентів (додаток А, рис. А.21).
Для доступу до основного функціоналу системи, необхідно мати чітко визначену роль, що надається користувачеві адміністратором: адміністратор, лікар, завідуючий складом. Якщо у користувача не визначено ролі, то він автоматично стає гостем та немає доступу до функціоналу. 
При авторизації необхідно ввести пароль та пошту, які валідуються (умови валідації вказані у моделі View), для реєстрації першим кроком є теж саме, тобто спочатку потрібно зареєструватися як користувач, а потім – як працівник, ввівши більше даних про себе. Далі дані моделі направляються на сервер, який у разі успішної реєстрації/авторизації надає токен доступу (JWT-токен), та дані про роль користувача, які потів зберігаються у cookies сайту. Якщо користувач тільки зареєструвався, то роль йому повинен надавати адміністратор, що має відповідну сторінку для організації цього процесу.
Після авторизації користувачу надається меню з усіма можливостями, що відповідають його ролі (описано у розділі 3.1). Далі буде наведено декілька прикладів програмної реалізації системи.
На прикладі коду нижче наведено, як відбувається авторизація, вхід в систему:

1	[HttpPost]
2	public async Task<IActionResult> Login(LoginModel model)
3	{
4	    string error = await GetUser(model);
5	    model.error = error;
6	    if (!String.IsNullOrEmpty(res))
7	    {
8	        return View(model);
9	    }
10	        return RedirectToAction("Index", "Home");
11	    }

На цьому прикладі можна побачити, що це POST метод (рядок 1), тобто на сторінці входу користувачу необхідно заповнити форму та підтвердити її, після чого викликається цей метод. В рядку 4 викликається метод, що робить запит на сервер, для того, щоб перевірити, чи існує користувач в системі. В рядках 6-10 перевіряється, чи успішно авторизовано користувача, то він направляється на головну сторінку, в іншому випадку користувач залишається на сторінці авторизації та у формі показується повідомлення про помилку.
В методі було викликано метод Index контролеру Home:

1	 public async Task<IActionResult> Index()
2	 {
3	      var animals = await GetAnimals();
4	      return View(animals);

5	 }

В цьому методі викликається метод для отримання тварин (рядок 3) та перенаправлення на View з отриманим списком (рядок 4).
Код метода для отримання всіх тварин наведено в додатку Б. По-перше, в цій функції використовується конструкція try-catch (рядки 16-24) для відстеження несподіваних помилок, таких, наприклад, як зупинена робота серверної частини. Далі використовується HTTP-клієнт (рядок 4), який є кастомізований (у заголовок додається токен доступу), створюється ендпоинт (url необхідного  методу на сервері) в рядку 5, який використовується для GET запиту (рядок 7). Запит повертає список тварин в JSON-форматі, тому при успішному запиті його відповідь необхідно десереалізувати. Для цього відповідь перетворюється в строку (рядок 11), після встановлюються опції для десеріалізації (рядки 12-14), які необхідні для правильного створення об’єкту. При помилці відправлення запиту створюється новий список та запам’ятовується помилка, яка буде виведена користувачеві (рядки 22-23). Інші сторінки працюють схожим чином: методи контролера роблять запити на сервер для отримання даних, які потім передаються на View. У разі помилки її текст запам’ятовується і виводиться на View користувачеві. Для відтворення графіків використовувалась бібліотека Highcharts.
В системі є локалізація. Доступні 2 мови: англійська та українська. При виборі англійської мови температура відображається в Фаренгейтах, дата в форматі UTC та у вигляді рік-місяць-день. При виборі української мови, температура відображається у Цельсіях, дата за Києвом у форматі день-місяць-рік. 
В додатку Б також наведено метод для додавання нового плану харчування тварини в базу даних. Цей метод бере вписані користувачем дані з форми, перевіряє формат дати (час), якщо встановлена не англійська локалізація та переводить у такому випадку в UTC формат (рядки 4-10), після чого спочатку план серіалізується, а потім робиться POST-запит на сервер (рядок 19), при помилці створення користувач повертається до головну сторінку. 
Також є функціонал для створення резервної копії даних, що при натисканні кнопки на сторінці робить запит на сервер, що повертає файл backup.bak та автоматично завантажує користувачеві. Приклад отримання наведено у додатку Б.
 
5	МОБІЛЬНИЙ ЗАСТОСУНОК
5.1	моделлювання програмної системи


Для розгляду функціональності було створено декілька Use-Case діаграм для різних ролей системи. 
В системі взагалі є декілька ролей: адміністратор (директор), лікар, відповідальний за постачання. Функціонал адміністратора включає доступ до всіх можливостей інших ролей та управління персоналом (наведено на Use-Case діаграмі додатку А, рис. А.22). 
Далі можна розглянути Use-Case діаграму для лікаря (наведено у додатку А, рис А.23). На діаграмі можна побачити одного діючого актора – лікаря, що має можливість переглядати та оновлювати інформацію про тварину, умови її життя в вольєрі. 
Роль відповідального за постачання включає в себе контроль кількості продуктів та розхідних матеріалів а складі. Цей функціонал наведено на Use-Case діаграмі 3 (додаток А,  рис А.24). 
Також функціонал адміністратора та послідовність його дій з тваринами можна побачити на діаграмі активності (додаток А, рис А.25). На цій діаграмі наведено можливі функції та дії адміна (директора) з тваринами: перегляд даних тварини, їх редагування, перегляд та редагування сенсору, вольєру (умов в вольєрі), перегляд даних сенсорів. Для всіх змін адміністратору необхідно підтверджувати особистість за допомогою вводу паролю та пройти перевірку на рівень доступу.


5.2	Взаємодія між частинами системи


Взаємодія клієнтської частини з іншими частинами системи буде відбуватися через серверну частину, до якої будуть робитися HTTP-запити, а саме: GET, POST, PUT, DELETE. З серверної частини можуть повертатися дані у різному форматі: об’єкти – у JSON форматі, в якій серіалізуються отримані з бази даних об’єкти, повідомлення про успішне створення, редагування, видалення, оновлення даних – за допомогою різних кодів (основні – 401, 400, 404, 200, 500).  
В якості прикладу взаємодії було створено діаграму взаємодії на роботи адміністратора з працівниками (додаток А, рис. А.26). На цій діаграмі можна докладніше поглянути на послідовність дій самої програми та як відбувається взаємодія з серверною частиною.


5.3	Архітектура програмної системи


Мобільний програмний застосунок розроблено для операційної системи IOS за допомогою технології SwiftUI на мові програмування Swift. В цій технології використовується декларативний підхід для створення сторінок, тобто дизайн (елементи сторінки) пишуться разом із бізнес-логікою. Тобто немає окремих файлів для View. 
Використовується архітектура MVVM, тому проект-застосунку було поділено на декілька папок: папка з моделями, які використовуються і у серверній частини, і у базі даних, та DTO-моделями (data transfer object), які містять не всі поля класу, а тільки ті, що не містять вразливої інформації а також у моделях існують методи для отримання відповідних даних з серверної частини. Об’єкти DTO отримуються з сервера або передаються на нього (наприклад, при реєстрації та авторизації, отримання даних про працівників), папка зі сторінками (Views), папка з вью-моделями (Viewmodel), що є проміжних шаром між моделлю та View і необхідна для трансформації або додаткової обробки даних, що приходять з серверної частини, для правильного відображення на сторінці View.
В системі реалізовано локалізацію англійською та українською, тобто змінюється мова інтерфейсу, формат дати, для чого було створено 2 файли ресурсів (String Catalog), в яких у вигляді ключа-значення знаходиться текст, що використовується на сторінках. Локалізація змінюється у відповідному розділі налаштувань у вигляді меню, з якого можна обрати необхідну мову. Також у цьому ж розділі можна обрати шкалу вимірювання температури, Цельсії або Фаренгейти. Всі налаштування зберігаються у пам’яті, виділеною для додатку, тому вони запам’ятовуються між запусками додатку, через що не потрібно кожен раз перелаштовувати систему.
Клієнтська частина взаємодіє з серверною за допомогою HTTP-запитів (GET, POST, PUT, DELETE).


5.4	Програмна розробка системи


Для візуалізації взаємодії моделей (класів) між собою було розроблено діаграму компонентів (додаток А, рис. А.27).
Далі буде наведено повний процес перегляду тварин. Спочатку користувач авторизувався, після чого його переносить на сторінку всіх тварин. У цьому коді наведено приклад функції для отримання списку тварин із сервера:

1	public static func GetAllAnimals(completion: @escaping (Result<Array<Animal>, Error>) -> Void) {
2	  let url = "api/Animals"
3	  
4	  let httpClient = HttpClient.createRequest(url: url, method: .GET)
5	  if(httpClient == nil){
6	      completion(Result.failure(AnimalError.programError))
7	      return
8	  }
9	  
10	let task = URLSession.shared.dataTask(with: httpClient!){ (data, response, error) in
11	      
12	   if(!HttpClient.checkResponseAndError(response: response, error: error)){
13	      return
14	   }
15	      
16	  if let data = data {
17	    do {
18	        if let jsonString = String(data: data, encoding: .utf8) {
19	           print("Received JSON: \(jsonString)")
20	        }
21	        var decodedData = try JSONDecoder().decode(Array<Animal>.self, from: data)
22	        completion(.success(decodedData))
23	    } catch {
24	        print("Decoding error: \(error.localizedDescription)")
25	        print(error)
26	        completion(.failure(error))
27	    }
28	   }
29	  }
30	 task.resume()
31	}

Функція GetAllAnimals викликається з параметром completion, який є замиканням для обробки результату (рядок 1), створюється URL-рядок для запиту (рядок 2), після чого ініціалізується об'єкт HttpClient для виконання GET-запиту на вказаній URL (рядок 4). Якщо HttpClient не створено, викликається замикання completion з помилкою (рядки 5-7). Створюється завдання сесія для виконання запиту (рядок 9), далі перевіряється наявність помилок у відповіді сервера за допомогою відповідного методу (рядок 11). Якщо отримано дані (рядок 16), вони декодуються з формату JSON в масив об'єктів Animal (рядки 21-23), і у разі успішного декодування викликається замикання completion з результатом успіху і переданими даними (рядок 22). У разі виникнення помилки при декодуванні, помилка виводиться на консоль і викликається замикання completion з результатом невдачі (рядки 24-26). В кінці це завдання з запитом викликається. 
Таким чином, цей код виконує GET-запит до API для отримання списку тварин, обробляє відповідь сервера, декодує отримані дані з формату JSON у масив об'єктів Animal, і повертає результат через замикання completion. У разі виникнення помилок, вони обробляються і передаються у замиканні.
Для показу динамічного створення сторінок, тобто коли інформація різна, але повинна однаково відображатися на сторінці, як, наприклад, сторінка редактора тварини, наведено код у додатку Б. Цей код представляє структуру AnimalEditorView, яка є представленням у SwiftUI для редагування даних про тварину. Структура приймає об'єкт типу Animal, з яким працює через прив'язку @Binding, і замикання updateInDB, яке викликається для оновлення даних у базі даних. Також визначено стан @State для збереження дати народження (dob) (рядки 1-4).
Основне тіло представлення складається з форми, яка містить дві секції. У першій секції користувач може вводити або редагувати ім'я тварини через текстове поле, яке прив'язане до властивості name об'єкта animal(рядки 9-12). У другій секції знаходяться текстові поля для породи та статі тварини, розміщені в горизонтальному стеку (рядки 13-15). Далі у вертикальному стеку розміщено вибір дати для дати народження та текстове поле для введення ваги тварини, яке використовує спеціальний форматтер для числових (рядки 16-23).
Коли представлення зникає, обробник onDisappear (рядки 28-31) оновлює властивість dob об'єкта animal з використанням конвертера дат і викликає замикання updateInDB, щоб зберегти зміни у базі даних. У кінці визначено числовий форматтер (рядки 34-37), який налаштовується для використання з полем введення ваги.
В якості прикладу обробки замикання буде виступати метод для реєстрації користувача, що знаходиться у вьюмоделі користувача:

1	 public func RegisterUser(completion: @escaping (Result<Bool, Error>) -> Void){
2	        model.RegisterUser {result in
3	            switch result {
4	            case .success(true):
5	                self.model.GetUser(completion: completion)
6	            default:
7	                return
8	            }
9	        }
10	    }

Функція приймає замикання completion, яке обробляє результат операції і може повертати значення типу Result<Bool, Error> (рядок 1). Всередині функції викликається метод RegisterUser об'єкта model, який також приймає замикання як параметр (рядок 2). При отриманні результату виконується перевірка за допомогою оператора switch(рядки 3-8). Якщо результат є успішним (.success(true)), викликається метод GetUser об'єкта model (рядок 5), який передає отримане completion для обробки результату та що призначений для авторизації після реєстрації нового користувача. У всіх інших випадках функція просто повертається без додаткових дій. Таким чином, функція RegisterUser спочатку реєструє користувача, а у разі успіху виконує додатковий запит для отримання даних про користувача, передаючи результат через замикання completion.
	В системі є локалізація. Доступні 2 мови: англійська та українська. При виборі мови вона зберігається у пам’яті пристрою, тому залишається однією і тою ж самою в різних запусках додатку. Час модифікується відповідно до часового поясу (регіону), на який налаштований сам телефон. Також при включенні української мови дата має синій колір, якщо вона за зимовим часом, червоним – за літнім. Є можливість вибору шкали температури, Цельсій або Фаренгейт.
В додатку Б наведено View-модель для складу, в якій є методи для отримання наявності складу, отримання всіх замовлень та оновлення статусу замовлення.
 
ВИСНОВКИ


На основі сучасних технологій програмування, баз даних та смарт-пристроїв була розроблена комплексна система управління притулками для тварин. Розробка системи базувалася на комплексному аналізі потреб притулків, враховуючи вимоги до зберігання та обробки даних, управління ресурсами та поліпшення умов утримання тварин. 
Було розроблено кілька основних компонентів системи: серверна частина, веб-додаток, мобільний додаток та смарт-пристрій. Серверна частина керує доступом до даних та надає їх по запиту від інших частин. Веб-додаток дозволяє адміністраторам притулку керувати даними тварин, їх медичної інформації, ресурсами (харчуванням, медикаментами, іншим забезпеченням), працівниками. Мобільний додаток дозволяє швидко отримувати доступ до інформації про тварин, її редагувати. Смарт-пристрій дозволяє відстежувати показники умов середовища в вольєрах, такі як температура, вологість та рівень корму або води. Ці дані автоматично передаються до серверної частини системи для подальшого аналізу та дій.
Ця розробка дозволяє автоматизувати рутинні завдання, що знижує навантаження на персонал притулку, дозволяючи більше часу приділяти догляду за тваринами. Вона також забезпечує ефективне управління ресурсами притулку, здійснюючи контроль за різними запасами, що дозволяє своєчасно поповнювати їх і уникати дефіциту. Покращення умов утримання тварин досягається завдяки моніторингу умов середовища, що дозволяє швидко реагувати на зміни та забезпечувати комфортні умови для тварин, знижуючи рівень стресу та покращуючи їхнє здоров’я. 
Таким чином, реалізація даної системи управління притулками для тварин забезпечує значні покращення в організації роботи притулку, умови утримання тварин та підвищує загальну ефективність управління ресурсами. 
ПЕРЕЛІК ПОСИЛАНЬ


1.	Посилання на архів з кодом: https://github.com/NureLulakovaAnastasiia/apzkr-pzpi-21-2-lulakova-anastasiia     
2.	Посилання на проект у симуляторі Wokwi:         https://wokwi.com/projects/395484583539104769  
3.	Посилання на відеозапис: https://youtu.be/1wFTPILOqzs 

 
ДОДАТОК А
Схеми та діаграми


 
Рисунок А.1 – Use-Case діаграма адміністратора для серверної частини
 
Рисунок А.2 – Use-Case діаграма лікаря для серверної частини

 
 
Рисунок А.3 – Use-Case діаграма управлінця сховищем для серверної частини 

 
Рисунок А.4 – Діаграма активності для дій з працівниками для серверної частини 
 
Рисунок А.5 – Діаграма активності для дій лікаря з хворобами для серверної частини
 
Рисунок А.6 – Діаграма активності для дій з тваринами для серверної частини
 
Рисунок А.7 – ER-діаграма
  
Рисунок А.8 – Діаграма розгортання
 


 
Рисунок А.9 – Use-Case діаграма для розумного пристрою

 
Рисунок А.10– Use-Case діаграма користувача 


 
Рисунок А.11 – Діаграма активності для налаштувань системи 


 
Рисунок А.12 – Діаграма активності для обробки показників 

 
Рисунок А.13 – Діаграма взаємодії для обробки показників
 


 
Рисунок А.14 – Схема фізичної моделі

 
Рисунок А.15 – Діаграма станів для етапу налаштувань
 
Рисунок А.16 – Use-Case діаграма адміністратора для клієнтської частини


 
Рисунок А.17 – Use-Case діаграма лікаря для клієнтської частини
 

 
Рисунок А.18 – Use-Case діаграма управлінця сховищем для клієнтської частини

 
 
Рисунок А.19 – Діаграма активності для дій з тваринами для клієнтської частини
 
 
Рисунок А.20 – Діаграма взаємодії роботі з працівниками для клієнтської частини
 

 
Рисунок А.21 – Діаграма компонентів для моделей, зв’язаних з лікарем для клієнтської частини
 

 
Рисунок А.22 – Use Case діаграма адміністратора

 
Рисунок А.23 – Use Case діаграма лікаря для мобільного додатку

 
Рисунок А.24 – Use Case діаграма завідуючого складом для мобільного додатку
 

 
Рисунок А.25 – Діаграма активності для дій з тваринами для мобільного додатку

 
Рисунок А.26 – Діаграма компонентів для моделей мобільного додатку
 
 
Рисунок А.27 – Діаграма взаємодії при діях з працівниками для мобільного додатку 

 
ДОДАТОК Б
Приклади коду


Реалізація інтерфейсу IAnimalService
1	public class AnimalService : IAnimalService
2	    {
3	        private readonly SmartShelterDBContext _dbContext;
4	        private readonly IMapper _mapper;
5	
6	        public AnimalService(SmartShelterDBContext dbContext, IMapper mapper)
7	        {
8	  _dbContext = dbContext;
9	  _mapper = mapper;
10	        }
11	        public List<Animal> GetAll()
12	        {
13	  var animalList = _dbContext.Animals.ToList();
14	  return animalList;
15	        }
16	        public Animal? GetById(int id)
17	        {
18	  var animal = _dbContext.Animals.Find(id);
19	  return animal;
20	        }
21	        public bool AddAnimal(AddAnimalDto animalDto)
22	        {
23	  var animal = _mapper.Map<Animal>(animalDto);
24	  animal.AcceptanceDate = DateTime.Now;
25	  _dbContext.Add(animal);
26	  return _dbContext.SaveChanges() != 0;
27	        }
28	        public bool RemoveAnimal(int id)
29	        {
30	  var animal = GetById(id);
31	  if (animal == null) return false;
32	  var diseasesList = GetAnimalDiseases(animal.Id);
33	  foreach (var disease in diseasesList)
34	  {
35	      _dbContext.Remove(disease);
36	  }
37	  _dbContext.Remove(animal);
38	  return _dbContext.SaveChanges() != 0;
39	}



Метод для аналізу даних сенсора


1	public bool CheckConditions(SensorData sensorData)
2	        {
3	  var sensor = _dbContext.Sensors.FirstOrDefault(s => s.Id == sensorData.SensorId);
4	  if (sensor == null)
5	  {
6	      return false;
7	  }
8	
9	  var aviary = _dbContext.Aviaries.Include(x => x.AviaryCondition).Include(x => x.Animal).FirstOrDefault(x => x.Id == sensor.AviaryId);
10	  
11	  if (aviary != null && aviary.AviaryConditionId != null)
12	  {
13	      if (aviary.AnimalId == null)
14	      {
15	          return false;
16	      }
17	      string aviaryProblem = "";
18	      string problem = "";
19	      if (sensorData.Temperature > aviary.AviaryCondition.MaxTemperature)
20	      {
21	          problem += $" - Temperature  is equal to {sensorData.Temperature} and higher then needed ({aviary.AviaryCondition.MaxTemperature})\n";
22	          aviaryProblem += "\nDecrease temperature in " +
23	      (sensorData.Temperature - (aviary.AviaryCondition.MaxTemperature - aviary.AviaryCondition.MinTemperature) / 2);
24	      }
25	      else if (sensorData.Temperature < aviary.AviaryCondition.MinTemperature)
26	      {
27	          problem += $" - Temperature  is equal to {sensorData.Temperature} and lower then needed ({aviary.AviaryCondition.MinTemperature})\n";
28	          aviaryProblem += "\nIncrease temperature in " +
29	      ((aviary.AviaryCondition.MaxTemperature - aviary.AviaryCondition.MinTemperature) / 2 - sensorData.Temperature);
30	      }
31	
32	      if (sensorData.Humidity > aviary.AviaryCondition.MaxHumidity)
33	      {
34	          problem += $" - Humidity is equal to {sensorData.Humidity} and higher then needed ({aviary.AviaryCondition.MaxHumidity})\n";
35	          aviaryProblem += "\nit is necessary to increase the air humidifier setting by" +
36	      (aviary.AviaryCondition.MaxHumidity - aviary.AviaryCondition.MaxHumidity) / 2;
37	      }
38	      else if (sensorData.Humidity < aviary.AviaryCondition.MinHumidity)
39	      {
40	          problem += $" - Humidity  is equal to {sensorData.Humidity} and lower then needed ({aviary.AviaryCondition.MinHumidity})\n";
41	          aviaryProblem += "\nit is necessary to decrease the air humidifier setting by" +
42	      (aviary.AviaryCondition.MaxHumidity - aviary.AviaryCondition.MaxHumidity) / 2;
43	      }
44	
45	      var tenPercent = sensorData.Water / 10;
46	      if (sensorData.Water + tenPercent <= aviary.AviaryCondition.MinWater)
47	      {
48	          problem += $" - Water level is low and equal to {sensorData.Water} \n";
49	          aviaryProblem += "\nit is necessary to add more water, at least " + tenPercent;
50	      }
51	
52	      if (sensorData.IHS >= 70)
53	      {
54	          problem += "- risk of heat stress is ";
55	          aviaryProblem += "\nit is necessary to make temperature lower, give more water to pet";
56	
57	          if (sensorData.IHS <= 79)
58	          {
59	    problem += "moderate";
60	          }else if (sensorData.IHS >= 80 && sensorData.IHS < 89)
61	          {
62	    problem += "high";
63	          }
64	          else if (sensorData.IHS >= 89)
65	          {
66	    problem += "VERY HIGH";
67	    aviaryProblem += "YOU NEED TO HURRY UP AND HELP";
68	          }
69	      }
70	
71	      problem += CheckFood(sensorData.Food, sensorData.Date, aviary.Animal.Id);
72	
73	      if (problem.Length > 0)
74	      {
75	          problem = $"Your aviary {sensor.AviaryId} with {aviary.Animal.Name} has problems: \n" + problem;
76	
77	          var user = _dbContext.Users.FirstOrDefault(u => u.Id = id);
78	          if (user != null)
79	          {
80	    return SendEmail(user.Email, problem + "\n\n" + aviaryProblem, $"Problem with pet aviary {aviary.Animal.Name}");
81	          }
82	      }
83	
84	      else
85	      {
86	          return false;
87	      }
88	  }

Метод для відправки даних на сервер

1	void sendPostRequest() {
2	  Serial.println("POST data to server...");
3	  HTTPClient http;
4	  UTCTime = getCurrentUTCTime();
5	  const String path = "/add/sensordata";
6	  http.begin(serverAddress + path);
7	  http.addHeader("Content-Type", "application/json-patch+json");
8	  String jsonData = R"({
9	    "water": )" + String(water) + R"(,
10	    "food": )" + String(food) + R"(,
11	    "temperature": )" + String(temperature) + R"(,
12	    "humidity": )" + String(humidity) + R"(,
13	    "ihs": )" + String(IHS) + R"(,
14	    "date": ")" + String(UTCTime) + R"(",
15	    "forecast": )" + String(forecast) + R"(,
16	    "sensorId": )" + String(sensorId) + R"(
17	  })";
18	   Serial.println(jsonData);
19	  int httpResponseCode = http.POST(jsonData);
20	  if (httpResponseCode > 0) {
21	    Serial.print("HTTP Response code: ");
22	    Serial.println(httpResponseCode);
23	    String response = http.getString();
24	    Serial.println(response);
25	  } else {
26	    Serial.print("Error code: ");
27	    Serial.println(httpResponseCode);
28	  }
29	  http.end();
30	}

Метод для отримання всіх тварин

1	 public async Task<List<Animal>> GetAnimals()
2	 {
3	   var animals = new List<Animal>();
4	   var client = _tokenService.CreateHttpClient();
5	   string fullUrl = $"{GlobalVariables.backendAddress}/api/Animals";
6	
7	   HttpResponseMessage response = await client.GetAsync(fullUrl);
8	
9	  if (response.IsSuccessStatusCode)
10	  {
11	      string result = await response.Content.ReadAsStringAsync();
12	      JsonSerializerOptions options = new JsonSerializerOptions
13	      {
14	          PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
15	      };
16	      try
17	      {
18	          animals = JsonSerializer.Deserialize<List<Animal>>(result, options);
19	      }
20	      catch (Exception ex)
21	      {
22	         ViewData["error"] = ex.Message;
23	         return new List<Animal>();
24	      }
25	  }
26	  
27	  return animals;
28	}

Метод для створення нового плану харчування

1	[HttpPost]
2	  public async Task<IActionResult> AddMeal(AnimalDetailsVM vm)
3	  {
4	      var currentCulture = System.Globalization.CultureInfo.CurrentCulture;
5	      var isUtc = currentCulture.Name == "en-US";
6	      if (!isUtc)
7	      {
8	    TimeZoneInfo localTimeZone = TimeZoneInfo.Local;
9	    vm.NewMealPlan.Time = TimeZoneInfo.ConvertTimeToUtc(vm.NewMealPlan.Time, localTimeZone);
10	      }
11	      var client = _tokenService.CreateHttpClient();
12	      string fullUrl = $"{GlobalVariables.backendAddress}/addMealPlan";
13	      JsonSerializerOptions options = new JsonSerializerOptions
14	      {
15	    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
16	      };
17	      string json = JsonSerializer.Serialize(vm.NewMealPlan, options);
18	      var content = new StringContent(json, System.Text.Encoding.UTF8, "application/json");
19	      HttpResponseMessage response = await client.PostAsync(fullUrl, content);
20	      if (!response.IsSuccessStatusCode)
21	      {
22	    return RedirectToAction("index", "Home");
23	      }
24	      return RedirectToAction("Details", new { animalId = vm.NewMealPlan.AnimalId });
25	  }

Метод для отримання резервної копії даних з серверу

1	 public IActionResult DownloadFile()
2	  {
3	
4	      var client = _tokenService.CreateHttpClient();
5	      string fullUrl = $"{GlobalVariables.backendAddress}/api/Backup";
6	      var response = client.GetAsync(fullUrl).Result;
7	
8	      if (response.IsSuccessStatusCode)
9	      {
10	    var fileBytes = response.Content.ReadAsByteArrayAsync().Result;
11	
12	    var fileName = "backup.bak";
13	
14	    return File(fileBytes, "application/octet-stream", fileName);
15	      }
16	      else
17	      {
18	    return StatusCode((int)response.StatusCode, $"Error downloading file: {response.ReasonPhrase}");
19	      }
20	  }

Метод для відображення редактора тварин

1	struct AnimalEditorView: View {
2	    @Binding var animal:Animal
3	    var updateInDB: (Animal) -> Void
4	    @State var dob:Date
5	    
6	    
7	    var body: some View {
8	        Form {
9	            Section(header: Text("Name")){
10	                TextField("Name", text: $animal.name)
11	            }
12	            Section(header: Text("Details")){
13	                HStack{
14	                    TextField("Breed", text: $animal.breed)
15	                    TextField("Gender", text: $animal.gender)
16	                }
17	                VStack{
18	                    DatePicker(selection: $dob, displayedComponents: .date){
19	                        Text("DOB")
20	                    }
21	                    TextField("Weight", value: $animal.weight, formatter: formatter)
22	                        .textFieldStyle(RoundedBorderTextFieldStyle())
23	                        .padding()
24	                }
25	                
26	            }
27	        }
28	        .onDisappear {
29	            animal.dob = DateConverter.dateToSwiftString(dob)
30	            updateInDB(animal)
31	        }
32	    }
33	    
34	    let formatter: NumberFormatter = {
35	            let formatter = NumberFormatter()
36	            formatter.numberStyle = .decimal
37	            return formatter
38	        }()
39	}

ViewModel складу

1	class StorageVM: ObservableObject {
2	    @Published public var storage:Array<Storage> = []
3	    @Published public var orders:Array<Order> = []
4	    
5	    public func getFullStorage(){
6	        Storage.getFullStorage{ result in
7	            switch result{
8	            case .success(var storage):
9	                DispatchQueue.main.async {
10	                    for number in 0..<storage.count {
11	                        storage[number].date = DateConverter
12	                       .fromServerDateToString(dateString: storage[number].date, time: .omitted)
13	                    }
14	                    print(storage)
15	                    self.storage = storage
16	                }
17	            case .failure(let error):
18	                print(error)
19	            }
20	        }
21	    }
22	    
23	    public func getAllOrders(){
24	        Order.getAllOrders { result in
25	            switch result{
26	            case .success(var orders):
27	                DispatchQueue.main.async {
28	                    for number in 0..<orders.count {
29	                        orders[number].orderDate = DateConverter
30	                      .fromServerDateToString(dateString: orders[number].orderDate, time: .omitted)
31	                    }
32	                    print(orders)
33	                    self.orders = orders
34	                }
35	            case .failure(let error):
36	                print(error)
37	            }
38	        }
39	    }
40	    
41	    public func approveOrder(order:Order){
42	        order.approveOrder{ result in
43	            if(result){
44	                DispatchQueue.main.async {
45	                    self.storage.append(Storage(order: order))
46	                    self.storage = Storage.groupStorage(self.storage)
47	                    if let index = self.orders.firstIndex(where: {$0.id == order.id}){
48	                        self.orders[index].isApproved = true
49	                    }
50	                }
51	            }
52	        }
53	    }
54	}

 
ДОДАТОК В
Перевірка на плагіат



